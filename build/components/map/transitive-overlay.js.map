{"version":3,"sources":["transitive-overlay.js"],"names":["require","checkHiPPI","canvas","window","devicePixelRatio","PIXEL_RATIO","style","width","height","context","getContext","scale","zoomFactors","minScale","gridCellSize","internalVertexFactor","angleConstraint","mergeVertexThreshold","useGeographicRendering","TransitiveCanvasOverlay","map","props","leaflet","L","canvasLayer","delegate","addTo","nextProps","_transitive","transitiveData","updateData","render","_updateBoundsAndRender","routingType","activeItinerary","focusJourney","journeys","journey_id","mapBounds","getBounds","Transitive","data","initialBounds","getWest","getSouth","getEast","getNorth","zoomEnabled","autoResize","styles","display","console","log","setDisplayBounds","info","_initTransitive","mapSize","getSize","_lastMapSize","x","y","setDimensions","setCanvas","coords","fromProps","toProps","MapLayer","PropTypes","object","mapStateToProps","state","ownProps","activeSearch","otp","query","response","plan","itins","mapDispatchToProps"],"mappings":"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","sourcesContent":["import PropTypes from 'prop-types'\nimport { MapLayer, withLeaflet } from 'react-leaflet'\nimport L from 'leaflet'\nimport { connect } from 'react-redux'\nimport Transitive from 'transitive-js'\nimport isEqual from 'lodash.isequal'\n\nimport { getActiveSearch, getActiveItineraries } from '../../util/state'\nimport { itineraryToTransitive } from '../../util/map'\n\nrequire('./leaflet-canvas-layer')\n\n// TODO: move to util?\nfunction checkHiPPI (canvas) {\n  if (window.devicePixelRatio > 1) {\n    const PIXEL_RATIO = 2\n    canvas.style.width = canvas.width + 'px'\n    canvas.style.height = canvas.height + 'px'\n\n    canvas.width *= PIXEL_RATIO\n    canvas.height *= PIXEL_RATIO\n\n    var context = canvas.getContext('2d')\n    context.scale(PIXEL_RATIO, PIXEL_RATIO)\n  }\n}\n\nconst zoomFactors = [{\n  minScale: 0,\n  gridCellSize: 0,\n  internalVertexFactor: 0,\n  angleConstraint: 5,\n  mergeVertexThreshold: 0,\n  useGeographicRendering: true\n}]\n\nclass TransitiveCanvasOverlay extends MapLayer {\n  static propTypes = {\n    transitiveData: PropTypes.object\n  }\n\n  // React Lifecycle Methods\n\n  componentDidMount () {\n    const { map } = this.props.leaflet\n    L.canvasLayer()\n      .delegate(this) // -- if we do not inherit from L.CanvasLayer  we can setup a delegate to receive events from L.CanvasLayer\n      .addTo(map)\n  }\n\n  componentWillReceiveProps (nextProps) {\n    // Check if we received new transitive data\n    if (this._transitive && !isEqual(nextProps.transitiveData, this.props.transitiveData)) {\n      this._transitive.updateData(nextProps.transitiveData)\n      if (!nextProps.transitiveData) this._transitive.render()\n      else this._updateBoundsAndRender()\n    }\n\n    if ( // this block only applies for profile trips where active option changed\n      nextProps.routingType === 'PROFILE' &&\n      nextProps.activeItinerary !== this.props.activeItinerary\n    ) {\n      if (nextProps.activeItinerary == null) { // no option selected; clear focus\n        this._transitive.focusJourney(null)\n        this._transitive.render()\n      } else if (nextProps.transitiveData) {\n        this._transitive.focusJourney(nextProps.transitiveData.journeys[nextProps.activeItinerary].journey_id)\n        this._transitive.render()\n      }\n    }\n  }\n\n  componentWillUnmount () {\n    if (this._transitive) {\n      this._transitive.updateData(null)\n      this._transitive.render()\n    }\n  }\n\n  // Internal Methods\n\n  _initTransitive (canvas) {\n    const { map } = this.props.leaflet\n\n    // set up the transitive instance\n    const mapBounds = map.getBounds()\n    this._transitive = new Transitive({\n      data: this.props.transitiveData,\n      initialBounds: [[mapBounds.getWest(), mapBounds.getSouth()], [mapBounds.getEast(), mapBounds.getNorth()]],\n      zoomEnabled: false,\n      autoResize: false,\n      styles: require('./transitive-styles'),\n      zoomFactors,\n      display: 'canvas',\n      canvas\n    })\n\n    checkHiPPI(canvas)\n\n    // the initial map draw\n    this._updateBoundsAndRender()\n  }\n\n  _updateBoundsAndRender () {\n    if (!this._transitive) {\n      console.log('WARNING: Transitive object not set in transitive-canvas-overlay')\n      return\n    }\n\n    const mapBounds = this.props.leaflet.map.getBounds()\n    this._transitive.setDisplayBounds([[mapBounds.getWest(), mapBounds.getSouth()], [mapBounds.getEast(), mapBounds.getNorth()]])\n    this._transitive.render()\n  }\n\n  // Leaflet Layer API Methods\n\n  onDrawLayer (info) {\n    if (!this._transitive) this._initTransitive(info.canvas)\n\n    const mapSize = this.props.leaflet.map.getSize()\n    if (\n      this._lastMapSize && (\n        mapSize.x !== this._lastMapSize.x ||\n        mapSize.y !== this._lastMapSize.y\n      )\n    ) {\n      const canvas = info.canvas\n      checkHiPPI(canvas)\n      this._transitive.display.setDimensions(mapSize.x, mapSize.y)\n      this._transitive.display.setCanvas(canvas)\n    }\n\n    this._updateBoundsAndRender()\n\n    this._lastMapSize = this.props.leaflet.map.getSize()\n  }\n\n  createTile (coords) {\n  }\n\n  createLeafletElement (props) {\n  }\n\n  updateLeafletElement (fromProps, toProps) {\n  }\n}\n\n// connect to the redux store\n\nconst mapStateToProps = (state, ownProps) => {\n  const activeSearch = getActiveSearch(state.otp)\n  let transitiveData = null\n  if (activeSearch && activeSearch.query.routingType === 'ITINERARY' && activeSearch.response && activeSearch.response.plan) {\n    const itins = getActiveItineraries(state.otp)\n    // TODO: prevent itineraryToTransitive() from being called more than needed\n    transitiveData = itineraryToTransitive(itins[activeSearch.activeItinerary])\n  } else if (activeSearch && activeSearch.response && activeSearch.response.otp) {\n    transitiveData = activeSearch.response.otp\n  }\n\n  return {\n    transitiveData,\n    activeItinerary: activeSearch && activeSearch.activeItinerary,\n    routingType: activeSearch && activeSearch.query && activeSearch.query.routingType\n  }\n}\n\nconst mapDispatchToProps = {\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(withLeaflet(TransitiveCanvasOverlay))\n"]}