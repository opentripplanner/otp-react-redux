{"version":3,"sources":["api.js"],"names":["fetch","require","hasCar","coreUtils","itinerary","query","getTripOptionsFromQuery","getUrlParams","randId","storage","time","OTP_API_DATE_FORMAT","OTP_API_TIME_FORMAT","nonRealtimeRoutingResponse","routingRequest","routingResponse","routingError","toggleTracking","rememberSearch","forgetSearch","formatRecentPlace","place","type","icon","id","timestamp","Date","getTime","formatRecentSearch","url","otpState","currentQuery","isStoredPlace","indexOf","getActiveItinerary","activeItinerary","routingType","urlParams","searches","Object","keys","length","ui_activeItinerary","routingQuery","searchId","dispatch","getState","state","otp","isNewSearch","console","warn","constructRoutingQuery","getOtpFetchOptions","then","getJsonAndCheckResponse","json","response","user","trackRecent","from","to","location","catch","error","params","ui_activeSearch","updateOtpUrlParams","storeTripHistory","loggedInUser","res","status","Error","includeToken","apiBaseUrl","apiKey","token","config","api","persistence","otp_middleware","isOtpServerSameAsMiddleware","host","accessToken","ignoreRealtimeUpdates","rt","routingTypes","find","key","planEndpoint","port","path","getRoutingParams","qs","stringify","isItinerary","queryParams","filter","qp","name","applicable","forEach","rewriteFunction","itineraryRewrite","profileRewrite","assign","dateValid","date","isValid","timeValid","mode","includes","minTransitDistance","searchTimeout","onlyTransitTrips","startTimeValid","startTime","endTimeValid","endTime","parkAndRideError","parkAndRideResponse","parkAndRideQuery","endpoint","map","join","createQueryAction","bikeRentalError","bikeRentalResponse","bikeRentalQuery","carRentalResponse","carRentalError","carRentalQuery","vehicleRentalResponse","vehicleRentalError","vehicleRentalQuery","findStopResponse","findStopError","findStop","stopId","serviceId","postprocess","payload","findRoutesAtStop","findStopTimesForStop","noThrottle","findTripResponse","findTripError","findTrip","tripId","findStopsForTrip","findStopTimesForTrip","findGeometryForTrip","findStopsForTripResponse","findStopsForTripError","rewritePayload","stops","findStopTimesForTripResponse","findStopTimesForTripError","stopTimes","findGeometryForTripResponse","findGeometryForTripError","geometry","findStopTimesForStopResponse","findStopTimesForStopError","otherParams","nowInSeconds","Math","floor","findRoutesResponse","findRoutesError","findRoutes","routes","rte","findPatternsForRouteResponse","findPatternsForRouteError","findRouteResponse","findRouteError","findRoute","routeId","findPatternsForRoute","patterns","ptn","findGeometryForPattern","patternId","findGeometryForPatternResponse","findGeometryForPatternError","transportationNetworkCompanyEtaResponse","transportationNetworkCompanyEtaError","getTransportationNetworkCompanyEtaEstimate","companies","estimates","transportationNetworkCompanyRideResponse","transportationNetworkCompanyRideError","getTransportationNetworkCompanyRideEstimate","company","rideType","rideEstimate","receivedNearbyStopsResponse","receivedNearbyStopsError","findNearbyStops","radius","stop","distance","latitude","lat","longitude","lon","sort","a","b","max","slice","receivedRoutesAtStopResponse","receivedRoutesAtStopError","receivedStopsWithinBBoxResponse","receivedStopsWithinBBoxError","findStopsWithinBBox","clearStops","throttledUrls","now","TEN_SECONDS","window","setInterval","responseAction","errorAction","options","alternateTransitIndex","services","log","apiRoot","throttleKey","fetchOptions","setUrlSearch","replaceCurrent","base","router","pathname","otpParams"],"mappings":"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","sourcesContent":["/* globals fetch */\nimport { push, replace } from 'connected-react-router'\nimport haversine from 'haversine'\nimport moment from 'moment'\nimport hash from 'object-hash'\nimport coreUtils from '@opentripplanner/core-utils'\nimport queryParams from '@opentripplanner/core-utils/lib/query-params'\nimport { createAction } from 'redux-actions'\nimport qs from 'qs'\n\nimport { rememberPlace } from './map'\nimport { getStopViewerConfig, queryIsValid } from '../util/state'\nimport { getSecureFetchOptions } from '../util/middleware'\n\nif (typeof (fetch) === 'undefined') require('isomorphic-fetch')\n\nconst { hasCar } = coreUtils.itinerary\nconst { getTripOptionsFromQuery, getUrlParams } = coreUtils.query\nconst { randId } = coreUtils.storage\nconst { OTP_API_DATE_FORMAT, OTP_API_TIME_FORMAT } = coreUtils.time\n\n// Generic API actions\n\nexport const nonRealtimeRoutingResponse = createAction('NON_REALTIME_ROUTING_RESPONSE')\nexport const routingRequest = createAction('ROUTING_REQUEST')\nexport const routingResponse = createAction('ROUTING_RESPONSE')\nexport const routingError = createAction('ROUTING_ERROR')\nexport const toggleTracking = createAction('TOGGLE_TRACKING')\nexport const rememberSearch = createAction('REMEMBER_SEARCH')\nexport const forgetSearch = createAction('FORGET_SEARCH')\n\nfunction formatRecentPlace (place) {\n  return {\n    ...place,\n    type: 'recent',\n    icon: 'clock-o',\n    id: `recent-${randId()}`,\n    timestamp: new Date().getTime()\n  }\n}\n\nfunction formatRecentSearch (url, otpState) {\n  return {\n    query: getTripOptionsFromQuery(otpState.currentQuery, true),\n    url,\n    id: randId(),\n    timestamp: new Date().getTime()\n  }\n}\n\nfunction isStoredPlace (place) {\n  return ['home', 'work', 'suggested', 'stop'].indexOf(place.type) !== -1\n}\n\n/**\n * Compute the initial activeItinerary. If this is the first search of\n * session (i.e. searches lookup is empty/null) AND an activeItinerary ID\n * is specified in URL parameters, use that ID. Otherwise, use null/0.\n */\nfunction getActiveItinerary (otpState) {\n  let activeItinerary = otpState.currentQuery.routingType === 'ITINERARY' ? 0 : null\n  // We cannot use window.history.state here to check for the active\n  // itinerary param because it is unreliable in some states (e.g.,\n  // when the print layout component first loads).\n  const urlParams = getUrlParams()\n  if (\n    (!otpState.searches || Object.keys(otpState.searches).length === 0) &&\n    urlParams.ui_activeItinerary\n  ) {\n    activeItinerary = +urlParams.ui_activeItinerary\n  }\n  return activeItinerary\n}\n\n/**\n * Send a routing query to the OTP backend.\n *\n * NOTE: We need a random ID so that when a user reloads the page (clearing the\n * state), performs searches, and presses back to load previous searches\n * that are no longer contained in the state we don't confuse the search IDs\n * with search IDs from the new session. If we were to use sequential numbers\n * as IDs, we would run into this problem.\n */\nexport function routingQuery (searchId = null) {\n  return async function (dispatch, getState) {\n    const state = getState()\n    const otpState = state.otp\n\n    const isNewSearch = !searchId\n    if (isNewSearch) searchId = randId()\n    const routingType = otpState.currentQuery.routingType\n    // Don't permit a routing query if the query is invalid\n    if (!queryIsValid(otpState)) {\n      console.warn('Query is invalid. Aborting routing query', otpState.currentQuery)\n      return\n    }\n    const activeItinerary = getActiveItinerary(otpState)\n    dispatch(routingRequest({ activeItinerary, routingType, searchId }))\n\n    // fetch a realtime route\n    const query = constructRoutingQuery(otpState)\n    fetch(query, getOtpFetchOptions(state))\n      .then(getJsonAndCheckResponse)\n      .then(json => {\n        dispatch(routingResponse({ response: json, searchId }))\n        // If tracking is enabled, store locations and search after successful\n        // search is completed.\n        if (otpState.user.trackRecent) {\n          const { from, to } = otpState.currentQuery\n          if (!isStoredPlace(from)) {\n            dispatch(rememberPlace({ type: 'recent', location: formatRecentPlace(from) }))\n          }\n          if (!isStoredPlace(to)) {\n            dispatch(rememberPlace({ type: 'recent', location: formatRecentPlace(to) }))\n          }\n          dispatch(rememberSearch(formatRecentSearch(query, otpState)))\n        }\n      })\n      .catch(error => {\n        dispatch(routingError({ error, searchId }))\n      })\n    // Update OTP URL params if a new search. In other words, if we're\n    // performing a search based on query params taken from the URL after a back\n    // button press, we don't need to update the OTP URL.\n    // TODO: For old searches that we are re-running, should we be **replacing**\n    //  the URL params here (instead of **pushing** a new path to history like\n    //  what currently happens in updateOtpUrlParams)? That way we could ensure\n    //  that the path absolutely accurately reflects the app state.\n    const params = getUrlParams()\n    if (isNewSearch || params.ui_activeSearch !== searchId) {\n      dispatch(updateOtpUrlParams(otpState, searchId))\n    }\n\n    // Also fetch a non-realtime route.\n    //\n    // FIXME: The statement below may no longer apply with future work\n    // involving realtime info embedded in the OTP response.\n    // (That action records an entry again in the middleware.)\n    // For users who opted in to store trip request history,\n    // to avoid recording the same trip request twice in the middleware,\n    // only add the user Authorization token to the request\n    // when querying the non-realtime route.\n    //\n    // The advantage of using non-realtime route is that the middleware will be able to\n    // record and provide the theoretical itinerary summary without having to query OTP again.\n    // FIXME: Interestingly, and this could be from a side effect elsewhere,\n    // when a logged-in user refreshes the page, the trip request in the URL is not recorded again\n    // (state.user stays unpopulated until after this function is called).\n    //\n    const { user } = state\n    const storeTripHistory = user &&\n      user.loggedInUser &&\n      user.loggedInUser.storeTripHistory\n\n    fetch(constructRoutingQuery(otpState, true), getOtpFetchOptions(state, storeTripHistory))\n      .then(getJsonAndCheckResponse)\n      .then(json => {\n        // FIXME: This is only performed when ignoring realtimeupdates currently, just\n        // to ensure it is not repeated twice.\n        dispatch(nonRealtimeRoutingResponse({ response: json, searchId }))\n      })\n      .catch(error => {\n        console.error(error)\n        // do nothing\n      })\n  }\n}\n\nfunction getJsonAndCheckResponse (res) {\n  if (res.status >= 400) {\n    const error = new Error('Received error from server')\n    error.response = res\n    throw error\n  }\n  return res.json()\n}\n\n/**\n * This method determines the fetch options (including API key and Authorization headers) for the OTP API.\n * - If the OTP server is not the middleware server (standalone OTP server),\n *   an empty object is returned.\n * - If the OTP server is the same as the middleware server,\n *   then an object is returned with the following:\n *   - A middleware API key, if it has been set in the configuration (it is most likely required),\n *   - An Auth0 accessToken, when includeToken is true and a user is logged in (userState.loggedInUser is not null).\n * This method assumes JSON request bodies.)\n */\nfunction getOtpFetchOptions (state, includeToken = false) {\n  let apiBaseUrl, apiKey, token\n\n  const { api, persistence } = state.otp.config\n  if (persistence && persistence.otp_middleware) {\n    ({ apiBaseUrl, apiKey } = persistence.otp_middleware)\n  }\n\n  const isOtpServerSameAsMiddleware = apiBaseUrl === api.host\n  if (isOtpServerSameAsMiddleware) {\n    if (includeToken && state.user) {\n      const { accessToken, loggedInUser } = state.user\n      if (accessToken && loggedInUser) {\n        token = accessToken\n      }\n    }\n\n    return getSecureFetchOptions(token, apiKey)\n  } else {\n    return {}\n  }\n}\n\nfunction constructRoutingQuery (otpState, ignoreRealtimeUpdates) {\n  const { config, currentQuery } = otpState\n  const routingType = currentQuery.routingType\n  // Check for routingType-specific API config; if none, use default API\n  const rt = config.routingTypes && config.routingTypes.find(rt => rt.key === routingType)\n  const api = (rt && rt.api) || config.api\n  const planEndpoint = `${api.host}${api.port\n    ? ':' + api.port\n    : ''}${api.path}/plan`\n  const params = getRoutingParams(otpState, ignoreRealtimeUpdates)\n  return `${planEndpoint}?${qs.stringify(params)}`\n}\n\nfunction getRoutingParams (otpState, ignoreRealtimeUpdates) {\n  const { config, currentQuery } = otpState\n  const routingType = currentQuery.routingType\n  const isItinerary = routingType === 'ITINERARY'\n  let params = {}\n\n  // Start with the universe of OTP parameters defined in query-params.js:\n  queryParams\n    .filter(qp => {\n      // A given parameter is included in the request if all of the following:\n      // 1. Must apply to the active routing type (ITINERARY or PROFILE)\n      // 2. Must be included in the current user-defined query\n      // 3. Must pass the parameter's applicability test, if one is specified\n      return qp.routingTypes.indexOf(routingType) !== -1 &&\n        qp.name in currentQuery &&\n        (typeof qp.applicable !== 'function' || qp.applicable(currentQuery, config))\n    })\n    .forEach(qp => {\n      // Translate the applicable parameters according to their rewrite\n      // functions (if provided)\n      const rewriteFunction = isItinerary\n        ? qp.itineraryRewrite\n        : qp.profileRewrite\n      params = Object.assign(\n        params,\n        rewriteFunction\n          ? rewriteFunction(currentQuery[qp.name])\n          : { [qp.name]: currentQuery[qp.name] }\n      )\n    })\n\n  // Additional processing specific to ITINERARY mode\n  if (isItinerary) {\n    // override ignoreRealtimeUpdates if provided\n    if (typeof ignoreRealtimeUpdates === 'boolean') {\n      params.ignoreRealtimeUpdates = ignoreRealtimeUpdates\n    }\n\n    // check date/time validity; ignore both if either is invalid\n    const dateValid = moment(params.date, OTP_API_DATE_FORMAT).isValid()\n    const timeValid = moment(params.time, OTP_API_TIME_FORMAT).isValid()\n\n    if (!dateValid || !timeValid) {\n      delete params.time\n      delete params.date\n    }\n\n    // temp: set additional parameters for CAR_HAIL or CAR_RENT trips\n    if (\n      params.mode &&\n      (params.mode.includes('CAR_HAIL') || params.mode.includes('CAR_RENT'))\n    ) {\n      params.minTransitDistance = '50%'\n      // increase search timeout because these queries can take a while\n      params.searchTimeout = 10000\n    }\n\n    // set onlyTransitTrips for car rental searches\n    if (params.mode && params.mode.includes('CAR_RENT')) {\n      params.onlyTransitTrips = true\n    }\n\n  // Additional processing specific to PROFILE mode\n  } else {\n    // check start and end time validity; ignore both if either is invalid\n    const startTimeValid = moment(params.startTime, OTP_API_TIME_FORMAT).isValid()\n    const endTimeValid = moment(params.endTime, OTP_API_TIME_FORMAT).isValid()\n\n    if (!startTimeValid || !endTimeValid) {\n      delete params.startTimeValid\n      delete params.endTimeValid\n    }\n  }\n\n  // TODO: check that valid from/to locations are provided\n\n  // hack to add walking to driving/TNC trips\n  if (hasCar(params.mode)) {\n    params.mode += ',WALK'\n  }\n\n  return params\n}\n\n// Park and Ride location query\n\nexport const parkAndRideError = createAction('PARK_AND_RIDE_ERROR')\nexport const parkAndRideResponse = createAction('PARK_AND_RIDE_RESPONSE')\n\nexport function parkAndRideQuery (params) {\n  let endpoint = 'park_and_ride'\n  if (params && Object.keys(params).length > 0) {\n    endpoint += '?' + Object.keys(params).map(key => key + '=' + params[key]).join('&')\n  }\n  return createQueryAction(endpoint, parkAndRideResponse, parkAndRideError)\n}\n\n// bike rental station query\n\nexport const bikeRentalError = createAction('BIKE_RENTAL_ERROR')\nexport const bikeRentalResponse = createAction('BIKE_RENTAL_RESPONSE')\n\nexport function bikeRentalQuery (params) {\n  return createQueryAction('bike_rental', bikeRentalResponse, bikeRentalError)\n}\n\n// Car rental (e.g. car2go) locations lookup query\n\nexport const carRentalResponse = createAction('CAR_RENTAL_RESPONSE')\nexport const carRentalError = createAction('CAR_RENTAL_ERROR')\n\nexport function carRentalQuery (params) {\n  return createQueryAction('car_rental', carRentalResponse, carRentalError)\n}\n\n// Vehicle rental locations lookup query. For now, there are 3 seperate\n// \"vehicle\" rental endpoints - 1 for cars, 1 for bicycle rentals and another\n// for micromobility. In the future, the hope is to consolidate these 3\n// endpoints into one.\n\nexport const vehicleRentalResponse = createAction('VEHICLE_RENTAL_RESPONSE')\nexport const vehicleRentalError = createAction('VEHICLE_RENTAL_ERROR')\n\nexport function vehicleRentalQuery (params) {\n  return createQueryAction('vehicle_rental', vehicleRentalResponse, vehicleRentalError)\n}\n\n// Single stop lookup query\nconst findStopResponse = createAction('FIND_STOP_RESPONSE')\nconst findStopError = createAction('FIND_STOP_ERROR')\n\nexport function findStop (params) {\n  return createQueryAction(\n    `index/stops/${params.stopId}`,\n    findStopResponse,\n    findStopError,\n    {\n      serviceId: 'stops',\n      postprocess: (payload, dispatch) => {\n        dispatch(findRoutesAtStop(params.stopId))\n        dispatch(findStopTimesForStop(params))\n      },\n      noThrottle: true\n    }\n  )\n}\n\n// TODO: Optionally substitute GraphQL queries? Note: this is not currently\n// possible because gtfsdb (the alternative transit index used by TriMet) does not\n// support GraphQL queries.\n// export function findStop (params) {\n//   const query = `\n// query stopQuery($stopId: [String]) {\n//   stops (ids: $stopId) {\n//     id: gtfsId\n//     code\n//     name\n//     url\n//     lat\n//     lon\n//     stoptimesForPatterns {\n//       pattern {\n//         id: semanticHash\n//         route {\n//           id: gtfsId\n//           longName\n//           shortName\n//           sortOrder\n//         }\n//       }\n//       stoptimes {\n//         scheduledArrival\n//         realtimeArrival\n//         arrivalDelay\n//         scheduledDeparture\n//         realtimeDeparture\n//         departureDelay\n//         timepoint\n//         realtime\n//         realtimeState\n//         serviceDay\n//         headsign\n//       }\n//     }\n//   }\n// }\n// `\n//   return createGraphQLQueryAction(\n//     query,\n//     { stopId: params.stopId },\n//     findStopResponse,\n//     findStopError,\n//     {\n//       // find stop should not be throttled since it can make quite frequent\n//       // updates when fetching stop times for a stop\n//       noThrottle: true,\n//       serviceId: 'stops',\n//       rewritePayload: (payload) => {\n//         // convert pattern array to ID-mapped object\n//         const patterns = []\n//         const { stoptimesForPatterns, ...stop } = payload.data.stops[0]\n//         stoptimesForPatterns.forEach(obj => {\n//           const { pattern, stoptimes: stopTimes } = obj\n//           // It's possible that not all stop times for a pattern will share the\n//           // same headsign, but this is probably a minor edge case.\n//           const headsign = stopTimes[0]\n//             ? stopTimes[0].headsign\n//             : pattern.route.longName\n//           const patternIndex = patterns.findIndex(p =>\n//             p.headsign === headsign && pattern.route.id === p.route.id)\n//           if (patternIndex === -1) {\n//             patterns.push({ ...pattern, headsign, stopTimes })\n//           } else {\n//             patterns[patternIndex].stopTimes.push(...stopTimes)\n//           }\n//         })\n//         return {\n//           ...stop,\n//           patterns\n//         }\n//       }\n//     }\n//   )\n// }\n\n// Single trip lookup query\n\nexport const findTripResponse = createAction('FIND_TRIP_RESPONSE')\nexport const findTripError = createAction('FIND_TRIP_ERROR')\n\nexport function findTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}`,\n    findTripResponse,\n    findTripError,\n    {\n      postprocess: (payload, dispatch) => {\n        dispatch(findStopsForTrip({tripId: params.tripId}))\n        dispatch(findStopTimesForTrip({tripId: params.tripId}))\n        dispatch(findGeometryForTrip({tripId: params.tripId}))\n      }\n    }\n  )\n}\n\n// Stops for trip query\n\nexport const findStopsForTripResponse = createAction('FIND_STOPS_FOR_TRIP_RESPONSE')\nexport const findStopsForTripError = createAction('FIND_STOPS_FOR_TRIP_ERROR')\n\nexport function findStopsForTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}/stops`,\n    findStopsForTripResponse,\n    findStopsForTripError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          tripId: params.tripId,\n          stops: payload\n        }\n      }\n    }\n  )\n}\n\n// Stop times for trip query\n\nexport const findStopTimesForTripResponse = createAction('FIND_STOP_TIMES_FOR_TRIP_RESPONSE')\nexport const findStopTimesForTripError = createAction('FIND_STOP_TIMES_FOR_TRIP_ERROR')\n\nexport function findStopTimesForTrip (params) {\n  return createQueryAction(\n    `index/trips/${params.tripId}/stoptimes`,\n    findStopTimesForTripResponse,\n    findStopTimesForTripError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          tripId: params.tripId,\n          stopTimes: payload\n        }\n      },\n      noThrottle: true\n    }\n  )\n}\n\n// Geometry for trip query\n\nexport const findGeometryForTripResponse = createAction('FIND_GEOMETRY_FOR_TRIP_RESPONSE')\nexport const findGeometryForTripError = createAction('FIND_GEOMETRY_FOR_TRIP_ERROR')\n\nexport function findGeometryForTrip (params) {\n  const { tripId } = params\n  return createQueryAction(\n    `index/trips/${tripId}/geometry`,\n    findGeometryForTripResponse,\n    findGeometryForTripError,\n    {\n      rewritePayload: (payload) => ({ tripId, geometry: payload })\n    }\n  )\n}\n\nconst findStopTimesForStopResponse = createAction('FIND_STOP_TIMES_FOR_STOP_RESPONSE')\nconst findStopTimesForStopError = createAction('FIND_STOP_TIMES_FOR_STOP_ERROR')\n\n/**\n * Stop times for stop query (used in stop viewer).\n */\nexport function findStopTimesForStop (params) {\n  return function (dispatch, getState) {\n    let { stopId, ...otherParams } = params\n    // If other params not provided, fall back on defaults from stop viewer config.\n    const queryParams = { ...getStopViewerConfig(getState().otp), ...otherParams }\n    // If no start time is provided, pass in the current time. Note: this is not\n    // a required param by the back end, but if a value is not provided, the\n    // time defaults to the server's time, which can make it difficult to test\n    // scenarios when you may want to use a different date/time for your local\n    // testing environment.\n    if (!queryParams.startTime) {\n      const nowInSeconds = Math.floor((new Date()).getTime() / 1000)\n      queryParams.startTime = nowInSeconds\n    }\n    dispatch(createQueryAction(\n      `index/stops/${stopId}/stoptimes?${qs.stringify(queryParams)}`,\n      findStopTimesForStopResponse,\n      findStopTimesForStopError,\n      {\n        rewritePayload: (stopTimes) => {\n          return {\n            stopId,\n            stopTimes\n          }\n        },\n        noThrottle: true\n      }\n    ))\n  }\n}\n\n// Routes lookup query\n\nconst findRoutesResponse = createAction('FIND_ROUTES_RESPONSE')\nconst findRoutesError = createAction('FIND_ROUTES_ERROR')\n\nexport function findRoutes (params) {\n  return createQueryAction(\n    'index/routes',\n    findRoutesResponse,\n    findRoutesError,\n    {\n      serviceId: 'routes',\n      rewritePayload: (payload) => {\n        const routes = {}\n        payload.forEach(rte => { routes[rte.id] = rte })\n        return routes\n      }\n    }\n  )\n}\n\n// export function findRoutes (params) {\n//   const query = `\n// {\n//   routes {\n//     id: gtfsId\n//     color\n//     longName\n//     shortName\n//     mode\n//     type\n//     desc\n//     bikesAllowed\n//     sortOrder\n//     textColor\n//     url\n//     agency {\n//       id: gtfsId\n//       name\n//       url\n//     }\n//   }\n// }\n//   `\n//   return createGraphQLQueryAction(\n//     query,\n//     {},\n//     findRoutesResponse,\n//     findRoutesError,\n//     {\n//       serviceId: 'routes',\n//       rewritePayload: (payload) => {\n//         const routes = {}\n//         payload.data.routes.forEach(rte => { routes[rte.id] = rte })\n//         return routes\n//       }\n//     }\n//   )\n// }\n\n// Patterns for Route lookup query\n// TODO: replace with GraphQL query for route => patterns => geometry\nconst findPatternsForRouteResponse = createAction('FIND_PATTERNS_FOR_ROUTE_RESPONSE')\nconst findPatternsForRouteError = createAction('FIND_PATTERNS_FOR_ROUTE_ERROR')\n\n// Single Route lookup query\n\nexport const findRouteResponse = createAction('FIND_ROUTE_RESPONSE')\nexport const findRouteError = createAction('FIND_ROUTE_ERROR')\n\nexport function findRoute (params) {\n  return createQueryAction(\n    `index/routes/${params.routeId}`,\n    findRouteResponse,\n    findRouteError,\n    {\n      postprocess: (payload, dispatch) => {\n        // load patterns\n        dispatch(findPatternsForRoute({ routeId: params.routeId }))\n      },\n      noThrottle: true\n    }\n  )\n}\n\nexport function findPatternsForRoute (params) {\n  return createQueryAction(\n    `index/routes/${params.routeId}/patterns`,\n    findPatternsForRouteResponse,\n    findPatternsForRouteError,\n    {\n      rewritePayload: (payload) => {\n        // convert pattern array to ID-mapped object\n        const patterns = {}\n        payload.forEach(ptn => { patterns[ptn.id] = ptn })\n\n        return {\n          routeId: params.routeId,\n          patterns\n        }\n      },\n      postprocess: (payload, dispatch) => {\n        // load geometry for each pattern\n        payload.forEach(ptn => {\n          dispatch(findGeometryForPattern({\n            routeId: params.routeId,\n            patternId: ptn.id\n          }))\n        })\n      }\n    }\n  )\n}\n\n// Geometry for Pattern lookup query\n\nconst findGeometryForPatternResponse = createAction('FIND_GEOMETRY_FOR_PATTERN_RESPONSE')\nconst findGeometryForPatternError = createAction('FIND_GEOMETRY_FOR_PATTERN_ERROR')\n\nexport function findGeometryForPattern (params) {\n  return createQueryAction(\n    `index/patterns/${params.patternId}/geometry`,\n    findGeometryForPatternResponse,\n    findGeometryForPatternError,\n    {\n      rewritePayload: (payload) => {\n        return {\n          routeId: params.routeId,\n          patternId: params.patternId,\n          geometry: payload\n        }\n      }\n    }\n  )\n}\n\n// export function findRoute (params) {\n//   const query = `\n//   query routeQuery($routeId: [String]) {\n//     routes (ids: $routeId) {\n//       id: gtfsId\n//       patterns {\n//         id: semanticHash\n//         directionId\n//         headsign\n//         name\n//         semanticHash\n//         geometry {\n//           lat\n//           lon\n//         }\n//       }\n//     }\n//   }\n//   `\n//   return createGraphQLQueryAction(\n//     query,\n//     { routeId: params.routeId },\n//     findPatternsForRouteResponse,\n//     findPatternsForRouteError,\n//     {\n//       rewritePayload: (payload) => {\n//         // convert pattern array to ID-mapped object\n//         const patterns = {}\n//         payload.data.routes[0].patterns.forEach(ptn => {\n//           patterns[ptn.id] = {\n//             routeId: params.routeId,\n//             patternId: ptn.id,\n//             geometry: ptn.geometry\n//           }\n//         })\n//\n//         return {\n//           routeId: params.routeId,\n//           patterns\n//         }\n//       }\n//     }\n//   )\n// }\n\n// TNC ETA estimate lookup query\n\nexport const transportationNetworkCompanyEtaResponse = createAction('TNC_ETA_RESPONSE')\nexport const transportationNetworkCompanyEtaError = createAction('TNC_ETA_ERROR')\n\nexport function getTransportationNetworkCompanyEtaEstimate (params) {\n  const {companies, from} = params\n  return createQueryAction(\n    `transportation_network_company/eta_estimate?${qs.stringify({\n      companies,\n      from\n    })}`, // endpoint\n    transportationNetworkCompanyEtaResponse, // responseAction\n    transportationNetworkCompanyEtaError, // errorAction\n    {\n      rewritePayload: (payload) => {\n        return {\n          from,\n          estimates: payload.estimates\n        }\n      }\n    }\n  )\n}\n\n// TNC ride estimate lookup query\n\nexport const transportationNetworkCompanyRideResponse = createAction('TNC_RIDE_RESPONSE')\nexport const transportationNetworkCompanyRideError = createAction('TNC_RIDE_ERROR')\n\nexport function getTransportationNetworkCompanyRideEstimate (params) {\n  const {company, from, rideType, to} = params\n  return createQueryAction(\n    `transportation_network_company/ride_estimate?${qs.stringify({\n      company,\n      from,\n      rideType,\n      to\n    })}`, // endpoint\n    transportationNetworkCompanyRideResponse, // responseAction\n    transportationNetworkCompanyRideError, // errorAction\n    {\n      rewritePayload: (payload) => {\n        return {\n          company,\n          from,\n          rideEstimate: payload.rideEstimate,\n          to\n        }\n      }\n    }\n  )\n}\n\n// Nearby Stops Query\n\nconst receivedNearbyStopsResponse = createAction('NEARBY_STOPS_RESPONSE')\nconst receivedNearbyStopsError = createAction('NEARBY_STOPS_ERROR')\n\nexport function findNearbyStops (params) {\n  return createQueryAction(\n    `index/stops?${qs.stringify({radius: 1000, ...params})}`,\n    receivedNearbyStopsResponse,\n    receivedNearbyStopsError,\n    {\n      serviceId: 'stops',\n      rewritePayload: stops => {\n        if (stops) {\n          // Sort the stops by proximity\n          stops.forEach(stop => {\n            stop.distance = haversine(\n              { latitude: params.lat, longitude: params.lon },\n              { latitude: stop.lat, longitude: stop.lon }\n            )\n          })\n          stops.sort((a, b) => { return a.distance - b.distance })\n          if (params.max && stops.length > params.max) stops = stops.slice(0, params.max)\n        }\n        return {stops}\n      },\n      // retrieve routes for each stop\n      postprocess: (stops, dispatch, getState) => {\n        if (params.max && stops.length > params.max) stops = stops.slice(0, params.max)\n        stops.forEach(stop => dispatch(findRoutesAtStop(stop.id)))\n      }\n    }\n  )\n}\n\n// Routes at Stop query\n\nconst receivedRoutesAtStopResponse = createAction('ROUTES_AT_STOP_RESPONSE')\nconst receivedRoutesAtStopError = createAction('ROUTES_AT_STOP_ERROR')\n\nexport function findRoutesAtStop (stopId) {\n  return createQueryAction(\n    `index/stops/${stopId}/routes`,\n    receivedRoutesAtStopResponse,\n    receivedRoutesAtStopError,\n    {\n      serviceId: 'stops/routes',\n      rewritePayload: routes => ({ stopId, routes }),\n      noThrottle: true\n    }\n  )\n}\n\n// Stops within Bounding Box Query\n\nconst receivedStopsWithinBBoxResponse = createAction('STOPS_WITHIN_BBOX_RESPONSE')\nconst receivedStopsWithinBBoxError = createAction('STOPS_WITHIN_BBOX_ERROR')\n\nexport function findStopsWithinBBox (params) {\n  return createQueryAction(\n    `index/stops?${qs.stringify(params)}`,\n    receivedStopsWithinBBoxResponse,\n    receivedStopsWithinBBoxError,\n    {\n      serviceId: 'stops',\n      rewritePayload: stops => ({stops})\n    }\n  )\n}\n\nexport const clearStops = createAction('CLEAR_STOPS_OVERLAY')\n\nconst throttledUrls = {}\n\nfunction now () {\n  return (new Date()).getTime()\n}\n\nconst TEN_SECONDS = 10000\n\n// automatically clear throttled urls older than 10 seconds\nwindow.setInterval(() => {\n  Object.keys(throttledUrls).forEach(key => {\n    if (throttledUrls[key] < now() - TEN_SECONDS) {\n      delete throttledUrls[key]\n    }\n  })\n}, 1000)\n\n/**\n * Generic helper for constructing API queries. Automatically throttles queries\n * to url to no more than once per 10 seconds.\n *\n * @param {string} endpoint - The API endpoint path (does not include\n *   '../otp/routers/router_id/')\n * @param {Function} responseAction - Action to dispatch on a successful API\n *   response. Accepts payload object parameter.\n * @param {Function} errorAction - Function to invoke on API error response.\n *   Accepts error object parameter.\n * @param {Options} options - Any of the following optional settings:\n *   - rewritePayload: Function to be invoked to modify payload before being\n *       passed to responseAction. Accepts and returns payload object.\n *   - postprocess: Function to be invoked after responseAction is invoked.\n *       Accepts payload, dispatch, getState parameters.\n *   - serviceId: identifier for TransitIndex service used in\n *       alternateTransitIndex configuration.\n *   - fetchOptions: fetch options (e.g., method, body, headers).\n */\n\nfunction createQueryAction (endpoint, responseAction, errorAction, options = {}) {\n  return async function (dispatch, getState) {\n    const otpState = getState().otp\n    let url\n    if (options.serviceId && otpState.config.alternateTransitIndex &&\n      otpState.config.alternateTransitIndex.services.includes(options.serviceId)\n    ) {\n      console.log('Using alt service for ' + options.serviceId)\n      url = otpState.config.alternateTransitIndex.apiRoot + endpoint\n    } else {\n      const api = otpState.config.api\n      url = `${api.host}${api.port ? ':' + api.port : ''}${api.path}/${endpoint}`\n    }\n\n    if (!options.noThrottle) {\n      // don't make a request to a URL that has already seen the same request\n      // within the last 10 seconds\n      const throttleKey = options.fetchOptions\n        ? `${url}-${hash(options.fetchOptions)}`\n        : url\n      if (throttledUrls[throttleKey] && throttledUrls[throttleKey] > now() - TEN_SECONDS) {\n        // URL already had a request within last 10 seconds, warn and exit\n        console.warn(`Request throttled for url: ${url}`)\n        return\n      } else {\n        throttledUrls[throttleKey] = now()\n      }\n    }\n    let payload\n    try {\n      const response = await fetch(url, options.fetchOptions)\n      if (response.status >= 400) {\n        const error = new Error('Received error from server')\n        error.response = response\n        throw error\n      }\n      payload = await response.json()\n    } catch (err) {\n      return dispatch(errorAction(err))\n    }\n\n    if (typeof options.rewritePayload === 'function') {\n      dispatch(responseAction(options.rewritePayload(payload)))\n    } else {\n      dispatch(responseAction(payload))\n    }\n\n    if (typeof options.postprocess === 'function') {\n      options.postprocess(payload, dispatch, getState)\n    }\n  }\n}\n\n// TODO: Determine how we might be able to use GraphQL with the alternative\n// transit index. Currently this is not easily possible because the alternative\n// transit index does not have support for GraphQL and handling both Rest and\n// GraphQL queries could introduce potential difficulties for maintainers.\n// function createGraphQLQueryAction (query, variables, responseAction, errorAction, options) {\n//   const endpoint = `index/graphql`\n//   const fetchOptions = {\n//     method: 'POST',\n//     body: JSON.stringify({ query, variables }),\n//     headers: { 'Content-Type': 'application/json' }\n//   }\n//   return createQueryAction(\n//     endpoint,\n//     responseAction,\n//     errorAction,\n//     { ...options, fetchOptions }\n//   )\n// }\n\n/**\n * Update the browser/URL history with new parameters\n * NOTE: This has not been tested for profile-based journeys.\n */\nexport function setUrlSearch (params, replaceCurrent = false) {\n  return function (dispatch, getState) {\n    const base = getState().router.location.pathname\n    const path = `${base}?${qs.stringify(params)}`\n    if (replaceCurrent) dispatch(replace(path))\n    else dispatch(push(path))\n  }\n}\n\n/**\n * Update the OTP Query parameters in the URL and ensure that the active search\n * is set correctly. Leaves any other existing URL parameters (e.g., UI) unchanged.\n */\nexport function updateOtpUrlParams (otpState, searchId) {\n  const otpParams = getRoutingParams(otpState)\n  return function (dispatch, getState) {\n    const params = {}\n    // Get all OTP-specific params, which will be retained unchanged in the URL\n    const urlParams = getUrlParams()\n    Object.keys(urlParams)\n      .filter(key => key.indexOf('_') !== -1)\n      .forEach(key => { params[key] = urlParams[key] })\n    params.ui_activeSearch = searchId\n    // Assumes this is a new search and the active itinerary should be reset.\n    params.ui_activeItinerary = 0\n    // Merge in the provided OTP params and update the URL\n    dispatch(setUrlSearch(Object.assign(params, otpParams)))\n  }\n}\n"]}