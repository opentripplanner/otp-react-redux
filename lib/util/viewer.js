/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-use-before-define */
import { getMostReadableTextColor } from '@opentripplanner/core-utils/lib/route'
import tinycolor from 'tinycolor2'

import { DARK_TEXT_GREY } from '../components/util/colors'

import { checkForRouteModeOverride } from './config'
import { getOperatorAndRoute } from './state'
import { isBlank } from './ui'

/**
 * Computes the seconds until departure for a given stop time,
 * based either on the scheduled or the realtime departure time.
 */
export function getSecondsUntilDeparture(stopTime, useSchedule) {
  const departureTime = useSchedule
    ? stopTime.scheduledDeparture
    : stopTime.realtimeDeparture

  return departureTime + stopTime.serviceDay - Date.now() / 1000
}

export function getRouteIdForPattern(pattern) {
  const patternIdParts = pattern.id.split(':')
  const routeId = patternIdParts[0] + ':' + patternIdParts[1]
  return routeId
}

/**
 * Checks that the given route object from an OTP pattern is valid.
 * If it is not, logs a warning message.
 *
 * FIXME: there is currently a bug with the alternative transit index
 *        where routes are not associated with the stop if the only stoptimes
 *        for the stop are drop off only. See https://github.com/ibi-group/trimet-mod-otp/issues/217
 *
 * @param {*} route The route of an OTP pattern to check.
 * @param {*} routeId The route id to show for the specified route.
 * @returns true if route is not null.
 */
export function routeIsValid(route, routeId) {
  if (!route) {
    console.warn(`Cannot render stop times for missing route ID: ${routeId}`)
    return false
  }
  return true
}

/**
 * Run heuristic on pattern description to extract headsign from pattern description
 * @param {*} pattern        pattern to extract headsign out of
 * @param {*} routeShortName if passed, used to help shorten headsign
 * @returns                  headsign of pattern
 */
export function extractHeadsignFromPattern(pattern, routeShortName = null) {
  let headsign = pattern.headsign
  // In case stop time headsign is blank, extract headsign from the pattern 'desc' attribute
  // (format: '49 to <Destination> (<destid>)[ from <Origin> (<originid)]').
  if (isBlank(headsign)) {
    const matches = pattern?.desc?.match(/(?: to )(.*?)(?: \()/)
    if (matches) {
      headsign = matches[1]
    }
  }

  // If that regex didn't work, try the old regex
  if (isBlank(headsign)) {
    const matches = pattern?.desc?.match(/ to ([^(from)]+) \(.+\)/)
    if (matches) {
      headsign = matches[1]
    }
  }

  /**
   * In some cases the string generated by OTP doesn't include a " "
   * see https://github.com/opentripplanner/OpenTripPlanner/blob/7ce72cf554e6cf469d683869db5684eae3ce86f8/src/main/java/org/opentripplanner/graph_builder/module/TripPatternNamer.java#L72-L183
   * In this case, we need to rely on the routeShortName to determine what to remove
   */
  if (isBlank(headsign) && routeShortName) {
    const matches = pattern?.desc?.match(/^[^(]*$/)
    if (matches) {
      headsign = matches[0].replace(`${routeShortName} `, '')
    }
  }

  // If the headsign is still blank, show the description
  if (isBlank(headsign)) {
    headsign = pattern?.desc || ''
  }

  // If we still don't have a headsign, maybe the long name will work?
  if (isBlank(headsign)) {
    headsign = pattern?.route?.longName || ''
  }

  return headsign
}

/**
 * Gets the mode string from either an OTP Route or RouteShort model. The OTP
 * Route model returns the mode as an integer type whereas the RouteShort model
 * returns the mode string.
 */
export function getModeFromRoute(route) {
  const modeLookup = {
    0: 'TRAM', // - Tram, Streetcar, Light rail.
    1: 'SUBWAY',
    // - Funicular.
    // TODO: 11 and 12 are not a part of OTP as of 2019-02-14, but for now just
    // associate them with bus/rail.
    // eslint-disable-next-line sort-keys
    11: 'BUS',

    // - Trolleybus.
    12: 'RAIL',

    // - Subway, Metro.
    2: 'RAIL',

    // - Rail. Used for intercity or long-distance travel.
    3: 'BUS',

    // - Bus.
    4: 'FERRY',

    // - Ferry.
    5: 'CABLE_CAR',

    // - Cable tram.
    6: 'GONDOLA',
    // - Gondola, etc.
    7: 'FUNICULAR' // - Monorail.
  }
  return route.mode || modeLookup[route.type]
}

/**
 * Gets the main mode from a stop. In most cases this is the single mode found.
 * In the case of a stop with multiple modes, this method will look at the most
 * frequently occurring mode and return that one.
 */
export const getModeFromStop = (stop, overrideConfig) => {
  const modes = [
    ...new Set(
      stop.routes?.map((route) =>
        checkForRouteModeOverride(route, overrideConfig)
      )
    )
  ]

  if (modes.length === 1) {
    return modes[0]
  }
  if (modes.length > 1) {
    const stopModeCounts = modes.reduce((modes, cur) => {
      if (!cur) {
        return modes
      }

      if (!modes[cur]) {
        modes[cur] = 0
      }
      modes[cur]++

      return modes
    }, {})

    // Get stop mode by getting most common stop mode
    return (
      stopModeCounts &&
      Object.keys(stopModeCounts)
        // Sort by mode occurrence
        .sort((a, b) => {
          return stopModeCounts[a] - stopModeCounts[b]
        })[0]
    )
  }
}

/**
 * Finds the stop time corresponding to the first departure
 * (the closest departure past the current time).
 */
export function getFirstDepartureFromNow(stopTimes) {
  // Search starting from the last stop time (largest seconds until departure).
  const lastStopTime = stopTimes[stopTimes.length - 1]

  let firstStopTime = lastStopTime
  stopTimes.forEach((stopTime) => {
    const firstStopTimeSeconds = getSecondsUntilDeparture(firstStopTime, true)
    const stopTimeSeconds = getSecondsUntilDeparture(stopTime, true)

    if (stopTimeSeconds < firstStopTimeSeconds && stopTimeSeconds >= 0) {
      firstStopTime = stopTime
    }
  })
  return firstStopTime
}

/**
 * Enum to represent transit realtime status for trips/stop times.
 */
export const REALTIME_STATUS = {
  EARLY: 'EARLY',
  LATE: 'LATE',
  ON_TIME: 'ON_TIME',
  SCHEDULED: 'SCHEDULED'
}

// Adjust the font size to avoid clipping of larger routeShortNames
export const routeNameFontSize = (routeName) => {
  let fontSize = '20px'
  if (routeName) {
    if (routeName?.length >= 3 && routeName?.length <= 6) {
      fontSize = '16px'
    } else if (routeName?.split(' ').some((x) => x.length > 8)) {
      fontSize = '12px'
    } else if (routeName?.length > 7) {
      fontSize = '14px'
    }
  }
  return fontSize
}

/**
 * Get one of the realtime states (on-time, late...) if a leg/stoptime is
 * registering realtime info and given a delay value in seconds.
 */
export function getTripStatus(
  isRealtime,
  delaySeconds,
  onTimeThresholdSeconds
) {
  if (isRealtime) {
    if (delaySeconds > onTimeThresholdSeconds) {
      // late departure
      return REALTIME_STATUS.LATE
    } else if (delaySeconds < -onTimeThresholdSeconds) {
      // early departure
      return REALTIME_STATUS.EARLY
    } else {
      // on-time departure
      return REALTIME_STATUS.ON_TIME
    }
  } else {
    // Schedule only
    return REALTIME_STATUS.SCHEDULED
  }
}

/**
 * Helper method that returns true only if an itinerary's first transit leg
 * has realtime info
 */
export function firstTransitLegIsRealtime(itinerary) {
  const firstTransitLeg = itinerary.legs.find((leg) => !!leg.transitLeg)
  return firstTransitLeg?.realTime
}

/**
 * Uses a long name splitter to prettify a route's long name
 */
function getCleanRouteLongName({ longNameSplitter, route }) {
  let longName = ''
  if (route.longName) {
    // Attempt to split route name if splitter is defined for operator (to
    // remove short name value from start of long name value).
    const nameParts = route.longName.split(longNameSplitter)
    longName =
      longNameSplitter && nameParts.length > 1 ? nameParts[1] : route.longName
    // If long name and short name are identical, set long name to be an empty
    // string.
    if (longName === route.shortName) longName = ''
  }
  return longName
}
/**
 * Using an operator and route, apply heuristics to determine color and contrast color
 * as well as a full route name
 */
export function getColorAndNameFromRoute(operator, route) {
  const { defaultRouteColor, defaultRouteTextColor, longNameSplitter } =
    operator || {}

  const modeColors = operator?.modeColors?.[getModeFromRoute(route)]

  const backgroundColor = `#${
    modeColors?.color || defaultRouteColor || route?.color || '333333'
  }`
  // NOTE: text color is not a part of short response route object, so there
  // is no way to determine from OTP what the text color should be if the
  // background color is, say, black. Instead, determine the appropriate
  // contrast color and use that if no text color is available.
  const contrastColor = getMostReadableTextColor(
    backgroundColor,
    modeColors?.textColor || route?.textColor
  )
  const color = `#${defaultRouteTextColor || contrastColor}`
  // Default long name is empty string (long name is an optional GTFS value).
  const longName = getCleanRouteLongName({ longNameSplitter, route })

  // Choose a color that the text color will look good against
  const softColor = tinycolor
    .mostReadable('#fff', [
      backgroundColor,
      tinycolor(backgroundColor).brighten(10).toHexString(),
      tinycolor(backgroundColor).brighten(20).toHexString(),
      tinycolor(backgroundColor).darken(10).toHexString()
    ])
    .toHexString()

  return {
    backgroundColor,
    color,
    longName,
    softColor
  }
}

/**
 * Helper method to determine a route color based on config color settings.
 *
 * Colors can be one of the following configured values:
 * - gtfs (default): colors are taken directly from gtfs/operator config
 * - gtfs-softened: colors are taken from gtfs/operator config and "softened" to be less intense
 * - disabled: color is always a generic gray
 */
export function getRouteColorBasedOnSettings(operator = {}, route = {}) {
  const { backgroundColor, softColor } = getColorAndNameFromRoute(
    operator,
    route
  )

  switch (operator.colorMode) {
    case 'disabled':
      return DARK_TEXT_GREY
    case 'gtfs-softened':
      return softColor
    default:
      return backgroundColor
  }
}

/**
 * Helper method to determine if a stop being viewed is a flex stop. This is not marked by
 * otp, so we must use the geometry type to determine flex status (flex stops do not use points)
 *
 * Extra null checks are needed to avoid mistaking a stop where data has not yet loaded for
 * a flex stop.
 */
export function stopIsFlex(stopData) {
  return (
    stopData &&
    stopData.geometries &&
    stopData.geometries.geoJson?.type !== 'Point'
  )
}

/**
 * The RouteRenderer requires a leg. To get it to render a Route object,
 * we use this method
 */
export function generateFakeLegForRouteRenderer(
  route,
  onColoredBackground = false
) {
  // RouteRenderer requires a "leg"
  return {
    agencyName: route?.agencyName || route.agency?.name,

    mode: getModeFromRoute(route),
    // Don't render top border when colors are mismatched
    onColoredBackground,
    origColor: route.origColor,
    routeColor: route.color,
    routeLongName: route.longName,
    routeShortName: route.shortName,
    routeTextColor: route.textColor
  }
}

/**
 * Gets a breadcrumbs-like page title for the route and pattern viewer,
 * so we don't need to internationalize the title bar structure:
 * - if no route is selected (or pattern is loading), just say "Route Viewer",
 * - if a route is selected, display the agency and user-facing route number,
 * - if a pattern is active, also show the pattern destination.
 */
export function getRouteOrPatternViewerTitle(
  transitOperators,
  viewedRouteObject,
  patternId,
  intl
) {
  const { patterns, pending, shortName } = viewedRouteObject || {}

  if (!viewedRouteObject || pending) {
    return intl.formatMessage({ id: 'components.RouteViewer.title' })
  }

  const pattern = patterns?.[patternId]
  return (
    getOperatorAndRoute(viewedRouteObject, transitOperators, intl) +
    (patternId && pattern
      ? ` ${intl.formatMessage({
          id: 'components.RouteDetails.stopsTo'
        })} ${extractHeadsignFromPattern(pattern, shortName)}`
      : '')
  )
}
